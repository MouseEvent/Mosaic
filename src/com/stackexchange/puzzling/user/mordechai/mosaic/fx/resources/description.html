<article class="markdown-body entry-content" itemprop="text">
	<p>
		<strong>Mosaic</strong> — Also known as: ArtMosaico, Count and Darken,
		Cuenta Y Sombrea, Fill-a-Pix, Fill-In, Komsu Karala, Magipic,
		Majipiku, Mosaico, Mosaik, Mozaiek, Nampre Puzzle, Nurie-Puzzle,
		Oekaki-Pix, Voisimage.
	</p>
	<p>Mosaic is a Minesweeper-like puzzle based on a grid with a
		pixel-art picture hidden inside. Using logic alone, the solver
		determines which squares are painted and which should remain empty
		until the hidden picture is completely exposed.</p>
	<p>Each puzzle consists of a grid containing clues in various
		places. The object is to reveal a hidden picture by painting the
		squares around each clue so that the number of painted squares,
		including the square with the clue, matches the value of the clue.</p>
	<p>
		Originally created by <a
			href="https://en.wikipedia.org/wiki/Trevor_Truran">Trevor Truran</a>,
		after inspiration of <a
			href="https://en.wikipedia.org/wiki/Conway's_Game_of_Life">Conway's
			Game of Life</a>.
	</p>
	<p>
		The puzzle was later developed by <a
			href="http://www.conceptispuzzles.com/index.aspx?uri=puzzle/fill-a-pix">ConceptisPuzzles</a>
		under the name <strong>Fill-a-Pix</strong>, following the "a-pix"
		pixel art series:
	</p>
	<ul>
		<li>
			<p>
				<a
					href="http://www.conceptispuzzles.com/index.aspx?uri=puzzle/pic-a-pix"><strong>Pic-a-Pix</strong></a>
				— Nonogram
			</p>
		</li>
		<li>
			<p>
				<a
					href="http://www.conceptispuzzles.com/index.aspx?uri=puzzle/sym-a-pix"><strong>Sym-a-Pix</strong></a>
			</p>
		</li>
		<li>
			<p>
				<a
					href="http://www.conceptispuzzles.com/index.aspx?uri=puzzle/link-a-pix"><strong>Link-a-Pix</strong></a>
			</p>
		</li>
		<li>
			<p>
				<a
					href="http://www.conceptispuzzles.com/index.aspx?uri=puzzle/maze-a-pix"><strong>Maze-a-Pix</strong></a>
			</p>
		</li>
		<li>
			<p>
				<a
					href="http://www.conceptispuzzles.com/index.aspx?uri=puzzle/dot-a-pix"><strong>Dot-a-Pix</strong></a>
			</p>
		</li>
		<li>
			<p>
				<a
					href="http://www.conceptispuzzles.com/index.aspx?uri=puzzle/cross-a-pix"><strong>Cross-a-Pix</strong></a>
			</p>
		</li>
		<li>
			<p>
				<a
					href="http://www.conceptispuzzles.com/index.aspx?uri=puzzle/block-a-pix"><strong>Block-a-Pix</strong></a>
			</p>
		</li>
	</ul>
	<p>I'll stick to the name "Mosaic" as the general name of this
		puzzle.</p>
	<p>Here are some links to understand the rules of the puzzle — all
		from ConceptisPuzzles:</p>
	<ul>
		<li><a
			href="http://www.conceptispuzzles.com/index.aspx?uri=puzzle/fill-a-pix/rules">Mosaic
				Rules</a></li>
		<li><a
			href="http://www.conceptispuzzles.com/index.aspx?uri=puzzle/fill-a-pix/tutorial">Animated
				Solving</a> — Requires Flash</li>
		<li><a
			href="http://www.conceptispuzzles.com/index.aspx?uri=puzzle/fill-a-pix/techniques">Basic
				Logic and Advanced Logic Techniques</a></li>
		<li><a
			href="http://www.conceptispuzzles.com/index.aspx?uri=puzzle/fill-a-pix/tips">Puzzle
				Tips</a></li>
		<li><a
			href="http://www.conceptispuzzles.com/index.aspx?uri=puzzle/fill-a-pix/history">Puzzle
				History</a></li>
	</ul>
	<hr>
	<h2>
		<a id="user-content-creating-your-own-mosaic" class="anchor"
			href="#creating-your-own-mosaic" aria-hidden="true"><svg
				aria-hidden="true" class="octicon octicon-link" height="16"
				version="1.1" viewBox="0 0 16 16" width="16">
				<path fill-rule="evenodd"
					d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating
		your own Mosaic
	</h2>
	<p>There are 3 rules that must be met when creating a Mosaic.
		Trying to solve them using the API will result in its appropriate
		exception to be thrown.</p>
	<ul>
		<li><strong>Every cell must have at-least one clue,
				either surrounding or in itself.</strong><br> <a
			href="https://i.stack.imgur.com/79JJE.png"><img
				src="https://camo.githubusercontent.com/7e236569f5df0572d3ac3564ee6ba8699ecbda03/68747470733a2f2f692e737461636b2e696d6775722e636f6d2f37394a4a452e706e67"
				alt="no-clue"
				data-canonical-src="https://i.stack.imgur.com/79JJE.png"
				style="max-width: 100%;"></a></li>
	</ul>
	<p>As you can see, the 3 right cells will never be solvable. Trying
		to solve this with the API will throw:</p>
	<pre>
		<code>    Exception in thread "main" com.stackexchange.puzzling.user.mordechai.mosaic.solvers.NoClueException: x: 3, y: 0
        at com.stackexchange.puzzling.user.mordechai.mosaic.solvers.AbstractSolveAlgorithm.&lt;init&gt;(AbstractSolveAlgorithm.java:37)
        at com.stackexchange.puzzling.user.mordechai.mosaic.solvers.RecursionSolver.&lt;init&gt;(RecursionSolver.java:32)
        at com.stackexchange.puzzling.user.mordechai.mosaic.solvers.RecursionSolver.&lt;init&gt;(RecursionSolver.java:28)
        at com.stackexchange.puzzling.user.mordechai.mosaic.TestPuzzle.main(TestPuzzle.java:14)
</code>
	</pre>
	<ul>
		<li><strong>Clues must not contradict.</strong><br> <a
			href="https://i.stack.imgur.com/tNld9.png"><img
				src="https://camo.githubusercontent.com/b2b50b60d058eeb95dd90c4e55158dfb2b5edb03/68747470733a2f2f692e737461636b2e696d6775722e636f6d2f744e6c64392e706e67"
				alt="contradiction"
				data-canonical-src="https://i.stack.imgur.com/tNld9.png"
				style="max-width: 100%;"></a></li>
	</ul>
	<p>Since 9 means all cells painted, the 2 will have 3 painted
		cells, which contradicts with the clue. Trying to solve this with the
		API will throw:</p>
	<pre>
		<code>    Exception in thread "main" com.stackexchange.puzzling.user.mordechai.mosaic.solvers.ContradictionException: x: 3, y: 1
        at com.stackexchange.puzzling.user.mordechai.mosaic.solvers.RecursionSolver.takeStepImpl(RecursionSolver.java:151)
        at com.stackexchange.puzzling.user.mordechai.mosaic.solvers.RecursionSolver.takeStep(RecursionSolver.java:127)
        at com.stackexchange.puzzling.user.mordechai.mosaic.solvers.RecursionSolver.run(RecursionSolver.java:90)
        at com.stackexchange.puzzling.user.mordechai.mosaic.solvers.RecursionSolver.start(RecursionSolver.java:56)
        at com.stackexchange.puzzling.user.mordechai.mosaic.TestPuzzle.main(TestPuzzle.java:23)
</code>
	</pre>
	<ul>
		<li><strong>Must have a unique solution.</strong> <br> If
			not enough clues are given there may be cases where 2 or more
			possible solutions are all correct according to the clues. <a
			href="https://i.stack.imgur.com/5nW7A.png"><img
				src="https://camo.githubusercontent.com/056c84666757f5cfbe17afe2900b72d29abf6044/68747470733a2f2f692e737461636b2e696d6775722e636f6d2f356e5737412e706e67"
				alt="unique"
				data-canonical-src="https://i.stack.imgur.com/5nW7A.png"
				style="max-width: 100%;"></a></li>
	</ul>
	<p>
		Once again, trying to solve a puzzle like this with this with
		<code>checkAmbiguity(true)</code>
		, will throw:
	</p>
	<pre>
		<code>    Exception in thread "main" com.stackexchange.puzzling.user.mordechai.mosaic.solvers.AmbigiousException: x: 3, y: 1
        at com.stackexchange.puzzling.user.mordechai.mosaic.solvers.RecursionSolver.lambda$5(RecursionSolver.java:224)
        at com.stackexchange.puzzling.user.mordechai.mosaic.solvers.AbstractSolveAlgorithm.fire(AbstractSolveAlgorithm.java:175)
        at com.stackexchange.puzzling.user.mordechai.mosaic.solvers.AbstractSolveAlgorithm.setState(AbstractSolveAlgorithm.java:82)
        at com.stackexchange.puzzling.user.mordechai.mosaic.solvers.RecursionSolver.setState(RecursionSolver.java:283)
        at com.stackexchange.puzzling.user.mordechai.mosaic.solvers.RecursionSolver.takeStep(RecursionSolver.java:119)
        at com.stackexchange.puzzling.user.mordechai.mosaic.solvers.RecursionSolver.takeStep(RecursionSolver.java:104)
        at com.stackexchange.puzzling.user.mordechai.mosaic.solvers.RecursionSolver.takeStep(RecursionSolver.java:104)
        at com.stackexchange.puzzling.user.mordechai.mosaic.solvers.RecursionSolver.run(RecursionSolver.java:90)
        at com.stackexchange.puzzling.user.mordechai.mosaic.solvers.RecursionSolver.start(RecursionSolver.java:56)
        at com.stackexchange.puzzling.user.mordechai.mosaic.TestPuzzle.main(TestPuzzle.java:23)
</code>
	</pre>
	<h2>
		<a id="user-content-using-the-application-programming-interface-api"
			class="anchor"
			href="#using-the-application-programming-interface-api"
			aria-hidden="true"><svg aria-hidden="true"
				class="octicon octicon-link" height="16" version="1.1"
				viewBox="0 0 16 16" width="16">
				<path fill-rule="evenodd"
					d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using
		the Application Programming Interface (API)
	</h2>
	<h3>
		<a id="user-content-1-kickstarter-" class="anchor"
			href="#1-kickstarter-" aria-hidden="true"><svg aria-hidden="true"
				class="octicon octicon-link" height="16" version="1.1"
				viewBox="0 0 16 16" width="16">
				<path fill-rule="evenodd"
					d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1.
		Kickstarter
	</h3>
	<p>
		The entry point is the class
		<code>Mosaic</code>
		that takes a
		<code>java.awt.Image</code>
		, URL or a
		<code>Grid&lt;Clue&gt;</code>
		- the logical representation of a grid used internally in
		<code>Mosaic</code>
		- as its constructor's parameters. The
		<code>Grid</code>
		will be filled with
		<code>Clues</code>
		. Here's the
		<code>Clue</code>
		class:
	</p>
	<pre>
		<code>package com.stackexchange.puzzling.user.mordechai.mosaic;

public class Clue {

	private Fill fill = Fill.EMPTY;
	private int clue = -1;
	private boolean isPixel;

	public Clue(Fill fill, int clue, boolean isPixel) {
		this.fill = fill;
		this.clue = clue;
		this.isPixel = isPixel;
	}

	public Clue(boolean isPixel) {
		this.isPixel = isPixel;
	}

	public Clue(Clue other) {
		if (other == null)
			return;

		this.fill = other.fill;
		this.clue = other.clue;
		this.isPixel = other.isPixel;
	}

	public Clue() {
	}

	public Fill getFill() {
		return fill;
	}

	public int getClue() {
		return clue;
	}

	public boolean isPixel() {
		return isPixel;
	}

	public void setFill(Fill fill) {
		this.fill = fill;
	}

	public void setClue(int clue) {
		this.clue = clue;
	}

	public void setIsPixel(boolean b) {
		isPixel = b;
	}

}
</code>
	</pre>
	<p>
		<code>Fill</code>
		is an enum with values
		<code>FILLED, EMPTY, X;</code>
	</p>
	<p>
		<strong>1.1 Filling Clues</strong>
	</p>
	<p>
		The
		<code>Mosaic</code>
		class itself just sets the
		<code>isPixel</code>
		of each clue according to the image, but the actual clues is up to the
		programmer to do.
		<code>Mosaic</code>
		has a method:
	</p>
	<pre>
		<code>public void putClues(ClueGenerator generator)
</code>
	</pre>
	<p>Which helps fill them up neatly.</p>
	<p>
		<code>ClueGenerator</code>
		is a functional interface:
	</p>
	<pre>
		<code>package com.stackexchange.puzzling.user.mordechai.mosaic;

import com.stackexchange.puzzling.user.mordechai.grid.Grid;

public interface ClueGenerator {

    boolean shouldGenerate(Grid&lt;Clue&gt; grid, int x, int y, int iteration);
	
	default int iterations() {
        return 0;
	}
}
</code>
	</pre>
	<p>Here's an example of creating and filling the clues with a
		checkerboard design:</p>
	<pre>Mosaic m = new Mosaic(getClass().getResource("empty-8x8.png"));
// empty-50x50.png is just a white empty image of size 8,8

<b>m.putClues((grid, x, y, iteration) -&gt; (x+y) % 2 == 0);</b>

System.out.println(m.getGrid().toGridString(
                   clue -&gt; " " + (clue.getClue() == -1 ? " " : clue.getClue()),
                   false)); // true would return with grid-lines</pre>
	<p>The above code prints to the console:</p>
	<pre>
		<code> 0   0   0   0  
   0   0   0   0
 0   0   0   0  
   0   0   0   0
 0   0   0   0  
   0   0   0   0
 0   0   0   0  
   0   0   0   0
</code>
	</pre>
	<p>You can as well do random fills or even make the clues be an
		image itself:</p>
	<pre>Grid grid = new Grid&lt;&gt;(20, 20);
grid.fill(Clue::new);

Mosaic m = new Mosaic(grid);

BufferedImage image = new BufferedImage(20, 20, BufferedImage.TYPE_INT_RGB);
Graphics g = image.getGraphics();

g.setColor(Color.WHITE);
g.fillRect(0, 0, 20, 20);
g.setColor(Color.BLACK);
g.setFont(new Font("Dialog", Font.BOLD, 25));
g.drawString("?", 2, 19);

g.dispose();

Mosaic q = new Mosaic(image);
m.putClues((gr, x, y, iteration) -&gt; <b>q.getGrid().get(x, y).isPixel()</b> || (x+y) % 4 == 0);

System.out.println(m.getGrid().toGridString(
                   clue -&gt; " " + (clue.getClue() == -1 ? " " : clue.getClue()),
                   false));</pre>
	<p>Results:</p>
	<pre>
		<code> 0       0       0       0       0      
       0       0 0 0 0 0       0       0
     0     0 0 0 0 0 0 0 0 0 0       0  
   0     0 0 0 0 0 0 0 0 0 0 0     0    
 0     0 0 0 0   0       0 0 0 0 0      
       0 0 0   0       0   0 0 0       0
     0       0       0     0 0 0     0  
   0       0       0     0 0 0 0   0    
 0       0       0     0 0 0 0   0      
       0       0     0 0 0 0   0       0
     0       0     0 0 0 0   0       0  
   0       0     0 0 0 0   0       0    
 0       0       0 0 0   0       0      
       0       0 0 0 0 0       0       0
     0       0       0       0       0  
   0       0       0       0       0    
 0       0       0 0 0   0       0      
       0       0 0 0 0 0       0       0
     0       0   0 0 0       0       0  
   0       0       0       0       0    
</code>
	</pre>
	<p>Ideas are virtually endless, show your creativity here.</p>
	<p>
		<strong>1.2 Iterations</strong>
	</p>
	<p>In some cases you will want to repeatedly iterate over the grid
		when filling the clues until some precondition is met (e.g. Fill
		randomly, then repeat and check if a cell has a missing clue).</p>
	<p>
		There's an overloaded version of
		<code>putClues()</code>
		:
	</p>
	<pre>
		<code>public void putClues(ClueGenerator generator, int iterations)
</code>
	</pre>
	<p>
		The process will repeat <em>n</em> times according to
		<code>iterations</code>
		. You can get the current iteration in the last argument of the clue
		generator.
	</p>
	<p>
		In the event that you want to write a general, full concrete
		implementation of
		<code>ClueGenerator</code>
		that heavily relies in the amount of iterations, you can override the
		default
		<code>iterations()</code>
		method. Any number greater that zero will always have precedence over
		the iterations parameter in
		<code>putClues()</code>
		. Zero or below will either use the
		<code>iterations</code>
		param or default to 1 if the first overload is used.
	</p>
	<h3>
		<a id="user-content-2-solving" class="anchor" href="#2-solving"
			aria-hidden="true"><svg aria-hidden="true"
				class="octicon octicon-link" height="16" version="1.1"
				viewBox="0 0 16 16" width="16">
				<path fill-rule="evenodd"
					d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2.
		Solving
	</h3>
	<p>
		To the current time, I've implemented one solve algorithm, namely
		<code>RecursionSolver</code>
		. As its name tells, it uses recursion. The regular case doesn't
		really require recursion to solve; it's the <a
			href="http://www.conceptispuzzles.com/index.aspx?uri=puzzle/fill-a-pix/techniques#advancedlogic">Advanced
			Logic</a> problems that recursion will be used for.
	</p>
	<p>
		Using it is easy, just create an instance, pass the
		<code>Mosaic</code>
		as constructor argument and start.
	</p>
	<pre>
		<code>Mosaic m = new Mosaic(...);
RecursionSolver rs = new RecursionSolver(m);
rs.start();
</code>
	</pre>
	<p>You can then output the results to the console:</p>
	<pre>
		<code>System.out.println(m.getGrid().toGridString(clue -&gt; " " + clue.getFill(), false));
</code>
	</pre>
	<p>And a report:</p>
	<pre>
		<code>System.out.println(rs.getReport());
</code>
	</pre>
	<p>
		<strong>2.1 Uniqueness</strong>
	</p>
	<p>As explained earlier, puzzles must follow some rules to be
		valid. Contradictions and missing clues are detected easily, but
		uniqueness requires to try all valid solutions and check if more than
		one is found.</p>
	<p>For this reason, I've designed the solver that uniqueness
		detection is off by default. You can toggle that behaviour:</p>
	<pre>
		<code>rs.checkAmbiguity(aBoolean);
</code>
	</pre>
	<h3>
		<a id="user-content-3-exporting-to-excel" class="anchor"
			href="#3-exporting-to-excel" aria-hidden="true"><svg
				aria-hidden="true" class="octicon octicon-link" height="16"
				version="1.1" viewBox="0 0 16 16" width="16">
				<path fill-rule="evenodd"
					d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3.
		Exporting to Excel
	</h3>
	<p>After you've created a Mosaic but you want to put it into Excel,
		you have to print a CSV version and just copy-paste it:</p>
	<pre>System.out.println(m.getGrid().toGridString(
                   clue -&gt; (clue.getClue() == -1 ? " " : clue.getClue()) <b>+ "\t"</b> ,
                   false));</pre>
	<p>My experience is that you should size the cells: Width: 1.86,
		Height: 13.5</p>
	<h3>
		<a id="user-content-4-attribution" class="anchor"
			href="#4-attribution" aria-hidden="true"><svg aria-hidden="true"
				class="octicon octicon-link" height="16" version="1.1"
				viewBox="0 0 16 16" width="16">
				<path fill-rule="evenodd"
					d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.
		Attribution
	</h3>
	<p>Much hard work has gone to develop this API. You are free to use
		it without limit and even create your own user interface version. If
		you publish a puzzle created by this API publicly on the Internet
		(intentionally excludes for private use), you should link this
		repository.</p>
</article>